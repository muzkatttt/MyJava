## Домашнее задание к семинару 5

### Задание 1.
_Представьте, что вы работаете над разработкой простого приложения для записной книжки,
которое позволяет пользователям добавлять, редактировать и удалять контакты.
Ваша задача - придумать как можно больше различных тестов
(юнит-тесты, интеграционные тесты, сквозные тесты) для этого приложения.
Напишите название каждого теста, его тип и краткое описание того, что этот тест проверяет._

При написании тестов не следует забывать о пирамиде тестирования Майка Кона, которая дает представление 
о более эффективном подходе к автоматизации тестирования, поэтому в домашней работе применяется принцип распределения 
количества тестов по уровням.
Первым этапом тестирования является написание unit-тестов, которые предназначены для надежной и быстрой
проверки небольших модулей кода. Для их написания используем фреймворк JUnit и Mockito. 
На этапе написания unit-тестов для приложения в качестве эксперимента создала три класса: 
- класс Contact, в котором есть поля класса, конструктор, и getter для обращения к полям класса;
- класс Note, в котором реализован список контактов, добавлены методы работы с контактами 
  (добавление, редактирование и удаление контактов); 
- класс NoteTests, в котором реализованы unit-тесты.

Применила аннотацию @BeforeEach с методом setUp() для того, чтобы в каждом тесте создавались новые объекты

    @ BeforeEach
    void setUp() {
    Contact contact = new Contact(1, "Max", "73222252");
    Contact contact1 = new Contact(2, "Alex", "11111111");
    }

Далее написаны unit-тесты:

    // unit-test проверка id контакта
    @Test
    void checkedId() {
        int id = 1;
        assertThat(id).isEqualTo(1);
    }

    // unit-test проверка имени контакта
    @Test
    void checkedName() {
        String name1 = "Max";
        assertThat(name1).isEqualTo("Max");
    }

    // unit-test проверка фамилии контакта
    @Test
    void checkedSurame() {
        String surname = "Petrov";
        assertThat(surname).isEqualTo("Petrov");
    }
    
    // unit-test проверка отчества контакта
    @Test
    void checkedSurame() {
        String patronymic = "Petrovich";
        assertThat(patronymic).isEqualTo("Petrovich");
    }


    // unit-test проверка номера телефона контакта
    @Test
    void checkedNumberOfTelephone() {
        String numberTelephone = "73222252";
        assertThat(numberTelephone).isEqualTo("73222252");
    }

    // unit-test добавление контакта в записную книжку
    @Test
    void testAddContactToNote() {
        //создаем список listContact и заполняем его данными
        List<Contact> note = new ArrayList<>();
        note.add(contact);
        note.add(contact1);

        // запускаем тест и проверяем добавлен ли контакт в записную книжку
        assertTrue(note.add(contact));
        assertTrue(note.add(contact1));

    }

    // unit-test удаление контакта из записной книжки с использованием Mockito
    @Test
    void testDeleteContact() {
        Note note = mock(Note.class);
        note.deleteContact(contact, listContacts);
        assertFalse(note == null);
    }

На втором этапе для написания интеграционных тестов необходима более детальная проработка кода, 
так как для их выполнения необходимо предусмотреть работу всего приложения, которая подразумевает разработку приложения
с использованием модели MVC. Предлагаемые интеграционные тесты:
1) Тестирование взаимодействия Model с View и с Controller.
    
        @Test
        void testModelView() {
            // тест проверяет, как взаимодействуют между собой два блока.
            // блок Model, который содержит методы работы приложения, классы и др.
            // с блоком View, который получает данные от Model с последующим выводом их для пользователя
        }

       @Test
       void testModelController() {
            // тест проверяет взаимодействие блока Controller, обрабатывающий 
            // действия пользователя и проверяющий полученную информацию, с блоком Model
       }

2) Тестирование базы данных контактов, например, с использованием TestContainers + JUnit:

       @TestContainers
       class NoteTests {
           private PostgreSQLContainer postgreSQLContainer = new PostgreSQLContainer()
               .withDatabaseId(1)
               .withIdContact(1);

           @Test
           void testNote() {
               assertThat(postgreSQLContainer.isRunning()).isTrue();
    

На третьем этапе, например, планируется, что наше приложение будет веб-приложением. 
Для проверки взаимодействия пользователя и приложения требуется написать сквозной тест с применением платформы Selenium:
В качестве примера предлагается написать автоматизированный тест для того, 
чтобы открыть страницу приложения в браузере и найти контакт по имени.

    @Test
    public void checkBrowserTest(){
        WebDriver driver = new ChromeDriver();
        driver.get("http://www.myNote.com");
        ...
        driver.quit();
    }

Таким образом, для итогового кейса по тестированию нашего приложения (записная книжка) 
тесты будут распределены по уровням тестирования следующим образом:
- unit-тесты составляют 70% тестов;
- интеграционные тесты составляют 20% от всех тестов;
- сквозные тесты составляют 10% от всех тестов.

### Задание 2.
_Ниже список тестовых сценариев.
Ваша задача - определить тип каждого теста (юнит-тест, интеграционный тест, сквозной тест)
и объяснить, почему вы так решили.
1) Проверка того, что функция addContact корректно добавляет новый контакт в список контактов.
2) Проверка того, что при добавлении контакта через пользовательский интерфейс,
контакт корректно отображается в списке контактов.
3) Проверка полного цикла работы с контактом: создание контакта, его редактирование и последующее удаление._

_1) Проверка того, что функция addContact корректно добавляет новый контакт в список контактов._
Данная проверка является unit-тестом и выполняется на начальном этапе тестирования.

_2) Проверка того, что при добавлении контакта через пользовательский интерфейс,
контакт корректно отображается в списке контактов._
Данная проверка относится к интеграционному тестированию, потому что взаимодействие блоков приложения между
собой осуществляется при интеграционном тестировании.

_3) Проверка полного цикла работы с контактом: создание контакта, его редактирование и последующее удаление._
Данная проверка сводится к проверке поведения конечного потребителя, поэтому она относится к сквозному тестированию.